import pandas as pd
from io import StringIO
from typing import Dict, Tuple
from grid_simulator.battery_simulator import BatterySimulator
from grid_simulator.solar_simulator import SolarSimulator
from grid_simulator.load_simulator import LoadSimulator
from grid_simulator.grid_feed_in_simulator import GridFeedInSimulator


class microGridSimulator:
    def __init__(self, start_step: int = 0, end_step: int = 0):

        self.current_step = start_step
        self.end_step = end_step

        # time interval in hours
        self.time_interval = 1

        # setup battery
        self.battery = BatterySimulator()
        self.solar = SolarSimulator()
        self.load = LoadSimulator()
        self.grid = GridFeedInSimulator()

        self.step_state(self.current_step)

    def step(self):
        self.current_step = self.current_step + 1
        self.step_state(self.current_step)

    def step_state(self, timestep: int) -> None:
        self.state: Dict[str, float] = {
            'load': self.load.get_current_load(timestep=timestep),
            'solar_gen': self.solar.get_current_solar_generation(
                timestep=timestep
            ),
            'tou_tariff': self.grid.get_current_tariff(timestep=timestep),
            'battery_soc': self.battery.get_soc(),
        }

    def get_current_state(self) -> Dict[str, float]:
        state = self.state
        return state

    def update_state(self, action: float):
        # impliment any control features and apply rules of the microgrid.
        # Finding a smart way to apply & Define these rules is important.
        # self.state = self.get_current_state()

        ## Things that I want to track #
        # Power Balance
        # Excess power generated
        # Energy Purchased from the grid by TOU
        to_purchase = 0
        charged_this_step = 0
        discharged_this_step = 0
        excess_this_step = 0
        unmet_demand_this_step = 0

        state: Dict[str, float] = self.get_current_state()

        # Will need to apply scaler here? Or should I scale somewhere else? (make a scaling function and apply it here)
        purchase_request: float = action

        # Power balance is calculated as the amount of energy generated by solar plus the purchase request minus the load.
        # Now we need to check if this is valid.
        energy_balance: float = (
            state['solar_gen'] - state['load']
        )  # (Units: kWh)

        if energy_balance > 0:
            to_purchase = self.positive_energy_balance(
                energy_balance=energy_balance,
                purchase_request=purchase_request,
            )
        else:
            if energy_balance + purchase_request > 0:
                to_purchase = self.artificial_positive_energy_balance(
                    energy_balance=energy_balance,
                    purchase_request=purchase_request,
                )
            else:
                to_purchase = self.negative_energy_balance(
                    energy_balance=energy_balance,
                    purchase_request=purchase_request,
                )
        energy_balance_with_grid = energy_balance + to_purchase
        if energy_balance_with_grid > 0:
            charged_this_step, excess_this_step = self.battery.charge(
                energy_balance_with_grid
            )
        else:
            discharged_this_step, unmet_demand_this_step = (
                self.battery.discharge(abs(energy_balance_with_grid))
            )
        result = {
            'to_purchase': to_purchase,
            'charged_this_step': charged_this_step,
            'discharged_this_step': discharged_this_step,
            'excess_this_step': excess_this_step,
            'unmet_demand_this_step': unmet_demand_this_step,
        }
        return result

    def artificial_positive_energy_balance(
        self, energy_balance: float, purchase_request: float
    ):
        """
        Use: Runs when the energy balance + the purchase request is positive. Decides how much of the purchase request can be fufilled.(Avoids trying to over charge the battery)
        Args:
            energy_balance (float): _description_
            purchase_request (float): _description_

        Returns:
            Float: Amount to be purchased, calculated from available capacity and the purchase request.
        """
        # Energy balance -5kwh, purchase request is 8 kwh, charge_capacity is 2kWh
        # to_purchase = min( -Energy_balance + max usable charge energy, purchase request)
        # to_purchase = min (- (-5) + 2, 8) = 7
        charge_capacity = self.battery.get_charge_capacity()
        to_purchase = min(-energy_balance + charge_capacity, purchase_request)
        return to_purchase

    def negative_energy_balance(
        self, energy_balance: float, purchase_request: float
    ) -> float:
        """
        Use: Runs when the Energy balance is negative. Decicdes where the energy should come from.
            Purchase request, then battery, then additional grid energy.
        Args:
            energy_balance (float): From Solar - load
            purchase_request (float): From agent

        Returns:
            Float: Amount to be purchased from the grid, inclusive of purchase request.
        """
        # Need to draw energy from grid or battery.
        # Get the ammount from the battery is available to be discharge.
        discharge_capacity = (
            self.battery.get_discharge_capacity()
            * self.battery.battery_efficiency
        )
        # energy_balance + purchase_request  is less than 0
        if discharge_capacity > abs(energy_balance + purchase_request):
            to_discharge = abs(energy_balance + purchase_request)
        else:
            to_discharge = discharge_capacity

        # additional_purchase = abs(-100 + 60 + 20) = 20
        additional_purchase = abs(
            energy_balance + purchase_request + to_discharge
        )
        to_purchase = purchase_request + additional_purchase

        return to_purchase

    def positive_energy_balance(
        self, energy_balance: float, purchase_request: float
    ) -> Tuple:
        # Check what the max usable energy is by checking how much energy can be stored in the battery.
        charge_capacity = self.battery.get_charge_capacity()
        # conver it to the max usable energy:
        charge_capacity = charge_capacity / self.battery.battery_efficiency

        # if the max usable energy is more thatn the available energy balance. Then you can purchase more energy.
        # if you can purchase more, then you can only purchase up to the available energy or less.
        # if the max usable energy is less than the energy balance then you can't request to purchase more because there will already be excess.
        if charge_capacity - energy_balance > 0:
            to_purchase = min(
                purchase_request, charge_capacity - energy_balance
            )
        else:
            to_purchase = 0

        return to_purchase

    # internal function to set the current step for testing purposes.
    def _set_step(self, step) -> None:
        self.current_step = step

    def _set_state(
        self,
        load: float,
        solar_gen: float,
        tou_tariff: float,
        battery_soc: float,
    ) -> None:
        """internal func for setting state during testing"""
        self.state: Dict[str, float] = {
            'load': load,
            'solar_gen': solar_gen,
            'tou_tariff': tou_tariff,
            'battery_soc': battery_soc,
        }
